%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Name: XeTeX+xeCJK日常使用模板
% Author: Lox Freeman
% Email: xiaohanyu1988@gmail.com
% 、
% 本文档可以自由转载、修改，希望能给广大TeXer的中文之路提供一些方便。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\documentclass[a4paper, 12pt, titlepage]{article}

%%%%%%%%%%%%%%%%%%%%%%%%% xeCJK相关宏包%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xltxtra,fontspec,xunicode}
\usepackage[slantfont, boldfont, CJKchecksingle]{xeCJK}

\CJKsetecglue{\hskip 0.15em plus 0.05em minus 0.05em}
% slanfont: 允许斜体
% boldfont: 允许粗体
% CJKnormalspaces: 仅忽略汉字之间的空白,但保留中英文之间的空白。
% CJKchecksingle: 避免单个汉字单独占一行。
% CJKaddspaces: [备选]忽略汉字之间的空白,并且自动在中英文转换时插入空白。

% \CJKlanguage{zh-cn}                 % 中文标点特殊处理
\XeTeXlinebreaklocale "zh"           % 针对中文进行断行
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
% 给予TeX断行一定自由度
%%%%%%%%%%%%%%%%%%%%%%%%% xeCJK%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%% 日常所用宏包、通通放在一起%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 什么常用的宏包都可以放这里。下面是我常用的宏包，每个都给出了简要注释
\usepackage[top=2.5cm, bottom=3cm, left=2.5cm, right=2.5cm]{geometry} % 控制页边距
\usepackage{enumerate}               % 控制项目列表
\usepackage{multicol}                % 多栏显示

\usepackage[%
pdfstartview=FitH,%
CJKbookmarks=true,%
bookmarks=true,%
bookmarksnumbered=true,%
bookmarksopen=true,%
colorlinks=true,%
citecolor=seco,%
linkcolor=seco,%
anchorcolor=seco,%
urlcolor=seco%
]{hyperref}                          % 超链接相关设置

\usepackage{titlesec}                % 控制标题
\usepackage{titletoc}                % 控制目录
\usepackage{type1cm}                 % 控制字体大小
\usepackage{indentfirst}             % 首行缩进，用\noindent取消某段缩进
\usepackage{bbding}                  % 一些特殊符号
\usepackage{cite}                    % 支持引用
\usepackage{framed,color,xcolor}     % 支持彩色文本、底色、文本框等
\usepackage{latexsym}                % LaTeX一些特殊符号宏包
\usepackage{amsmath}                 % AMS LaTeX宏包
\usepackage{bm}                      % 数学公式中的黑斜体
\usepackage{relsize}                 % 调整公式字体大小：\mathsmaller, \mathlarger
\usepackage{soul}                    % 下划线自动回车换行
\usepackage{attachfile}              % 添加附见使用的宏包
\usepackage{parcolumns}              % 列排版
\usepackage{framed}
\usepackage{tcolorbox}
\usepackage{pdfpages}                % 直接引用已有的PDF文件
\usepackage{soul}                    % 自动换行的下划线
\makeindex                           % 生成索引

\makeatletter
\let\std@footnotetext\@footnotetext
\usepackage{setspace}
\let\@footnotetext\std@footnotetext
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%% 绘图方法%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}                % 图形宏包
\graphicspath{{./figure/}{./figures/}{./image/}{./graphics/}{./graphic/}{./pictures/}{./picture/}}

\usepackage{tikz}
\usepackage{amsmath,bm,times}
\usepackage{verbatim}

\usepackage{tabularx}

\usetikzlibrary{shapes,arrows,shadows,fit,snakes,positioning,decorations,shapes.multipart}
\usetikzlibrary{decorations.shapes}
\usetikzlibrary{calc}           %coordinate

\usepackage{caption}
\usepackage{float}

\ifx\du\undefined
\newlength{\du}
\fi
\setlength{\du}{15\unitlength}

\newlength\Textwd
\setlength\Textwd{3cm}
\newcommand\Textbox[2]{%
  \parbox[c][#1][c]{\Textwd}{\linespread{0.5}\centering#2}}

\makeatletter
\DeclareRobustCommand{\rvdots}{%
  \vbox{
    \baselineskip6\p@\lineskiplimit\z@
    \kern-\p@
    \hbox{.}\hbox{.}\hbox{.}
  }}
\makeatother


\makeatletter
\DeclareRobustCommand{\rvdots}{%
  \vbox{
    \baselineskip4\p@\lineskiplimit\z@
    \kern-\p@
    \hbox{.}\hbox{.}\hbox{.}}}
\tikzset{
  heights/.code={
    \def\pgf@tempb{}%
    \foreach \qrr@tikz@rs@height[count=\qrr@tikz@count from 1] in {#1}{
      \edef\pgf@tempa{\noexpand\pgfkeysalso{/tikz/every \pgf@lib@sh@toalpha\qrr@tikz@count\space node part/.append style={height={\qrr@tikz@rs@height}}}}%
      \ifnum\qrr@tikz@count=1\relax % allows to use \nodepart{text} (or not at all for the first part)
      \edef\pgf@tempa{\unexpanded\expandafter{\pgf@tempa}\noexpand\pgfkeysalso{/tikz/every text node part/.append style={height={\qrr@tikz@rs@height}}}}%
      \fi
      \expandafter\pgfutil@g@addto@macro\expandafter\pgf@tempb\expandafter{\pgf@tempa}
    }
    \pgf@tempb
  },
  height/.code={%
    \expandafter\def\expandafter\pgfutil@minipage\expandafter[\expandafter##\expandafter 1\expandafter]\expandafter{\pgfutil@minipage[][#1][c]}% LaTeX only!
  }
}

\makeatother
\tikzset{rect/.style={
    draw,
    rectangle split,
    rectangle split parts=1,
    rectangle split part align=center,
    draw,
    % font=\ttfamily, % still works
    thick,
    text width=2.5cm,
    align=center,
    rectangle split part align={center,left,right},
    % rectangle split part fill={PaleTurquoise1},
  }}

% flowchart
\tikzset{
  decision/.style = {diamond, draw, fill=blue!20, 
    text width=8em, text badly centered, node distance=3cm, inner sep=0pt},
  block/.style = {rectangle, draw, fill=blue!20, 
    text width=8em, text centered, rounded corners, minimum height=2em},
  line/.style = {draw, -latex'},
  cloud/.style = {draw, ellipse,fill=red!20, node distance=3cm,
    minimum height=2em},
  subroutine/.style = {draw,rectangle split, rectangle split horizontal,
    rectangle split parts=3,minimum height=1cm,
    rectangle split part fill={red!50, green!50, blue!20, yellow!50}},
  connector/.style = {draw,circle,node distance=3cm,fill=yellow!20},
  data/.style = {draw, trapezium,node distance=3cm,fill=olive!20}
}

\makeatletter
\newcommand{\gettikzxy}[3]{%
  \tikz@scan@one@point\pgfutil@firstofone#1\relax
  \edef#2{\the\pgf@x}%
  \edef#3{\the\pgf@y}%
}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%% 绘图方法结束%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%% fancyhdr设置页眉页脚%%%%%%%%%%%%%%%%%%%%
\usepackage{etoolbox}
\usepackage{fancyhdr}                % 页眉页脚
\pagestyle{fancy}                    % 页眉页脚风格
\setlength{\headheight}{15pt}        % 有时会出现\headheight too small的warning

\makeatletter
\patchcmd{\@fancyhead}{\rlap}{\color{seco}\rlap}{}{}
\patchcmd{\headrule}{\hrule}{\color{seco}\hrule}{}{}
\patchcmd{\@fancyfoot}{\rlap}{\color{seco}\rlap}{}{}
\patchcmd{\footrule}{\hrule}{\color{seco}\hrule}{}{}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%% fancyhdr设置结束%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%% xeCJK字体设置%%%%%%%%%%%%%%%%%%%%%%%%%
\setmainfont[Ligatures=TeX]{Helvetica} % (\textrm)
\setsansfont{Helvetica}                % (\textsf)
\setmonofont{Monaco}        % Palatino Linotype

% \setCJKmainfont[BoldFont={PingFang-SC-Light},ItalicFont={PingFang-SC-Light}]{PingFang-SC-Light}
% \setCJKsansfont[BoldFont={PingFang-SC-Light}]{PingFang-SC-Light}
% \setCJKmonofont{PingFang-SC-Light}

\setCJKmainfont[BoldFont={Kaiti SC Regular},ItalicFont={Kaiti SC Regular}]{Kaiti SC Regular}
\setCJKsansfont[BoldFont={Kaiti SC Regular}]{Kaiti SC Regular}
\setCJKmonofont{Kaiti SC Regular}

%%%%%%%%%%%%%%%%%%%%%%%%% xeCJK字体设置结束%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%% listings宏包粘贴源码%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}                % 方便粘贴源代码，部分代码高亮功能
\lstloadlanguages{}                  % 所要粘贴代码的编程语言

\newfontfamily\listingsfont{Monaco}
\newfontfamily\listingsfontinline{Helvetica}

\definecolor{sh_keyword}{rgb}{0.06, 0.10, 0.98}   % #101AF9
\definecolor{shadecolor}{rgb}{0.83, 0.83, 0.83}
\definecolor{monokai-grey-dark}{RGB}{39, 40, 34}   % #272822
\definecolor{monokai-yellow-light}{RGB}{248, 248, 246}   % #F8F8F2
\definecolor{monokai-green}{RGB}{166, 226, 42}
\definecolor{dark green}{rgb}{0.000000,0.392157,0.000000}
\definecolor{forest green}{rgb}{0.133333,0.545098,0.133333}
\def\lstsmallmath{\leavevmode\ifmmode \scriptstyle \else  \fi}
\def\lstsmallmathend{\leavevmode\ifmmode  \else  \fi}

% \definecolor{seco}{RGB}{9,80,3}
% \definecolor{seco}{RGB}{0,145,215}
\definecolor{seco}{RGB}{0,175,152}
\definecolor{main}{RGB}{127,191,51}

% \makeatletter
%   \newcommand\listingfont{\@setfontsize\listingfont{11pt}{13.2pt}}
% \makeatother

\renewcommand{\lstlistingname}{代码}

\lstset {
  language=c++,
  backgroundcolor=\color{monokai-grey-dark},
  % frame=shadowbox,
  % breaklines,
  % rulesepcolor=\color{red!20!green!20!blue!20},
  showspaces=false,showtabs=false,tabsize=4,
  numberstyle=\tiny\color{black},numbers=left,
  % basicstyle= \listingfont\listingsfont\color{monokai-yellow-light},
  basicstyle= \small\listingsfont\color{monokai-yellow-light},
  stringstyle=\color{dark green},
  % keywordstyle = \color{monokai-green}\bfseries,
  keywordstyle = \color{monokai-green},
  commentstyle=\footnotesize\color{forest green}\itshape,
  captionpos=b,
  showspaces=false,showtabs=false, showstringspaces=false,
  xleftmargin=0.7cm, xrightmargin=0.5cm,
  % lineskip=-0.3em,
  breaklines=tr,
  escapebegin={\lstsmallmath}, escapeend={\lstsmallmathend},
  extendedchars=false
}

\lstnewenvironment{acol}[1][]{\lstset{language={[x86masm]Assembler},#1}}{}
\newenvironment{parcolumenv}[1] {\begin{spacing}{#1}}{\end{spacing}}
%%%%%%%%%%%%%%%%%%%%%%%%% listings宏包设置结束%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%% 一些关于中文文档的重定义%%%%%%%%%%%%%%%%%

%%%% 数学公式定理的重定义%%%%
\newtheorem{example}{例}                                   % 整体编号
\newtheorem{algorithm}{算法}
\newtheorem{theorem}{定理}[section]                        % 按 section 编号
\newtheorem{definition}{定义}
\newtheorem{axiom}{公理}
\newtheorem{property}{性质}
\newtheorem{proposition}{命题}
\newtheorem{lemma}{引理}
\newtheorem{corollary}{推论}
\newtheorem{remark}{注解}
\newtheorem{condition}{条件}
\newtheorem{conclusion}{结论}
\newtheorem{assumption}{假设}

%%%% 章节等名称重定义%%%%
\renewcommand{\contentsname}{目\hspace{2em}录}
\renewcommand{\indexname}{索引}
\renewcommand{\listfigurename}{插图目录}
\renewcommand{\listtablename}{表格目录}
\renewcommand{\figurename}{图}
\renewcommand{\tablename}{表}
\renewcommand{\appendixname}{附\hspace{2em}录}

%%%% 设置chapter、section与subsection的格式%%%%
\titleformat{\chapter}{\centering\huge}{\color{seco}第\thechapter{}章}{1em}{\color{seco}\textbf}
\titleformat{\section}{\centering\LARGE}{\color{seco}\thesection}{1em}{\color{seco}\textbf}
\titleformat{\subsection}{\Large}{\color{seco}\thesubsection}{1em}{\color{seco}\textbf}
%%%%%%%%%%%%%%%%%%%%%%%%% 中文重定义结束%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%% 一些个性设置%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parskip}{0.5\baselineskip}     % 设定段间距
\linespread{1.6}                           % 设定行距
\newcommand{\pozhehao}{\kern0.3ex\rule[0.8ex]{2em}{0.1ex}\kern0.3ex}% 中文破折号，据说来自清华模板

\setCJKfamilyfont{title}{Kaiti SC Regular}

\newcommand*{\TitleFont}{\usefont{\encodingdefault}{\rmdefault}{b}{n}\fontsize{32}{40}\selectfont\CJKfamily{title}\color{seco}}% 标题字体设置

\renewcommand{\today}{\color{seco}\number\year 年 \number\month 月 \number\day 日}
%%%%%%%%%%%%%%%%%%%%%%%%% 个性设置结束%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%% 正文部分%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\setlength{\parindent}{2em}
% 设定首行缩进为2em。注意此设置一定要在document环境之中。
% 这可能与\setlength作用范围相关

\title{\TitleFont codediff之内存泄露\vspace{8cm}}
\author{\href{mailto:q00148943@gmail.com}{\LARGE{秦新良}}}
\date{\vspace{0.5cm}\today}

\maketitle

\tableofcontents
\newpage

\section{引子}
某天的codediff准时进行，但由于diff的代码改动非常小，不到十分钟代码便分享完成，于是小伙伴们开始走读本次修改代码对应特性的老代码。

走读代码的过程中，发现了一段如\ref{lst1}所示的代码\footnote{本文中所引用的代码均是将业务逻辑剥离后的简化代码。}，引起了我的注意。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst1,caption=内存释放]{list/problem.cpp}
\end{spacing}

首先，该函数的内存使用没有遵守谁申请谁释放的原则。对于该场景，指针不需要在进程内传递，完全可以做到内存在同一函数内申请和释放。

其次，释放内存使用的是delete []，根据配对原则，在函数process中，必须使用new []申请内存。但跳转到process函数内，查看其申请内存的代码如\ref{lst2}所示。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst2,caption=内存申请]{list/memory.cpp}
\end{spacing}

我了个去，这是个什么鬼？这是我当时第一眼看到这个代码的感受。申请和释放内存的接口是配对使用了，但类型不匹配。

经过小伙伴们的激烈讨论，大家一致认为这个代码是有问题的，且问题是内存泄露，建议本次特性负责人在实际环境上给出验证结果。

但问题是否到此为至，除此之外是否还有其它问题？本文将探讨这种使用方法背后的原理及其可能引入的问题。

\section{C的malloc和free}
C语言中申请和释放内存的接口分别是malloc和free。程序调用malloc函数后，malloc返回一个void类型的指针，指向新申请内存的起始地址；内存使用结束后，调用free函数，传入malloc返回的指针，即可完成内存的释放。

问题：调用free函数只传入一个指针，并没有传入该指针指向的内存大小，free函数如何知道本次该释放多少内存？

要搞清楚这个问题，首先要搞清楚malloc是如何分配内存的。在glibc\footnote{本文引用的glibc代码的版本为glibc-2.19。}的实现中，函数\_\_libc\_malloc是malloc函数的一个strong\_alias，可简单理解为该函数就是malloc，其最终会调用\_int\_malloc函数来完成内存的分配，如代码\ref{lst3}所示。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst3,caption=malloc的实现]{list/malloc.c}
\end{spacing}

在代码\ref{lst3}中，函数\_int\_malloc的第二个参数bytes是直接从\_\_libc\_malloc函数透传下来的，即该参数的值就是程序调用malloc函数传入的参数。在该函数的开始处，有一段注释，说明了紧接着注释下面的
\begin{center}
\textsl{checked\_request2size (bytes, nb);}
\end{center}
这行代码的作用：{\color{blue}将请求的内存大小转换成内部实际分配的大小。具体的转换规则是外部请求大小 + SIZE\_SZ + 字节对齐\footnote{32位程序是8字节对齐。}，如果外部请求申请的内存太小，例如malloc(0)，这行代码会返回单次申请内存的最小值}。这个转换过程是通过两个宏定义来实现的，如代码\ref{lst4}所示。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst4,caption=request2size的实现]{list/request2size.c}
\end{spacing}
从上面的分析及源代码可以看出，glibc分配的内存一定大于程序申请的内存。经过glibc分配的内存，其布局如图\ref{fig01}所示。

\input{figure/malloc_memory_lay_out}
图\ref{fig01}中的user data即glibc返回给应用程序的可使用内存，该块内存大小大于等于程序申请的内存。紧接着这片内存的前4字节内存，保存了本次malloc实际分配的内存大小，即request2size的结果。

32位程序glibc分配内存是8字节对齐的，所以4字节的size其低3位肯定为0，glibc使用这三个bit保存额外的管理信息，即图\ref{fig01}中的的A、M和P三个bit。

glibc提供了malloc\_usable\_size()接口供应用程序获取实际分配（可使用）的内存大小\footnote{虽然glibc提供了该接口，但不建议应用程序调用该接口获取glic多分配的内存并使用该内存，应用程序还是按照自己申请的大小来使用。}，使用该接口即可验证上面的分析，验证代码如\ref{lst5}所示。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst5,caption=验证代码]{list/size.c}
\end{spacing}

编译\footnote{编译环境信息：OS(Ubuntu 14.04 x86\_64)、编译器(gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1))、编译参数(gcc -m32)。}代码\ref{lst5}，针对申请不同的内存大小做验证，结果如\ref{lst6}所示。从验证结果可以看出，malloc\_usable\_size()大于等于应用程序申请的内存大小，而size等于malloc\_usable\_size() + 4，且是8的整数倍。

\begin{spacing}{1.0}
  \lstinputlisting[language=sh,label=lst6,caption=验证结果]{list/size.sh}
\end{spacing}

一句话总结malloc：malloc在返回给应用程序内存地址的前4个字节地址处保存了本次分配的内存大小。

知道了malloc分配内存的原理，那如何在不传入长度的情况下正确的释放内存就很清楚了：根据应用程序传入的地址，向前偏移4个字节获取本次释放内存的大小并释放该大小的内存即可。

在glibc中，free函数的实现是\_\_libc\_free，该函数首先将应用程序传的的指针转换成chunk结构类型的指针，然后再调用\_int\_free完成内存的释放。在函数\_int\_free的开始便计算出了本次释放内存的大小，见代码\ref{lst7}。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst7,caption=free的实现]{list/free.c}
\end{spacing}

mem2chunk将mem指针减2*SIZE\_SZ后直接强转成malloc\_chunk类型的指针。32位程序SIZE\_SZ等于4，mem2chunk相当于mem指针减8再强转。chunksize则直接通过malloc\_chunk指针取其size成员。size是malloc\_chunk的第二个成员，相当于是计算malloc\_chunk指针加4地址的值。结合mem2chunk的定义，该取值相当于是取（mem - 8 + 4）地址的值，即free函数是通过应用程序传入地址的前4个字节来计算本次释放内存的大小。

\section{C++的new和delete}
C++中申请和释放内存的接口分别是new和delete。程序调用new函数后，new返回指定类型的指针，指向新申请对象的起始地址；内存使用结束后，调用delete函数，传入new返回的指针，即可完成内存的释放。

代码\ref{lst8}和代码\ref{lst9}分别是gcc\footnote{本文引用的gcc代码的版本为gcc-5.2.0。}的libstdc++中new和delete函数的实现。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst8,caption=new]{list/new.cpp}
\end{spacing}

\begin{spacing}{1.0}
  \lstinputlisting[label=lst9,caption=delete]{list/delete.cpp}
\end{spacing}
new函数的核心功能是调用malloc申请指定大小的内存，除此之外都是异常处理。而delete函数则更为简单，直接调用C的free函数释放内存，无任何其它处理。从new和delete函数的实现来看，其本质和C的malloc、free没有任何差异。

在C++中，使用new动态创建一个类的对象后，会自动调用该类的构造函数；使用delete销毁一个对象前，会自动调用其析构函数。但从代码\ref{lst8}和代码\ref{lst9}中new和delete的实现上来看，这两个函数本身并不会调用类的构造和析构函数。

构造和析构函数的调用，其实并不是new和delete函数的职责，而是编译器的责任\footnote{从局部变量在作用域开始生成并调用构造函数、作用域结束调用析构函数并销毁也可以说明构造和析构与new和delete无关，因为这种场景下根本不会有new和delete的参与。}。代码在编译阶段，编译器检测到对象的创建，便生成调用对象构造函数的代码；同理，检测到对象的销毁，便生成调用对象析构函数的代码\footnote{包括局部自动生成的对象和使用new动态创建的对象。}。

代码\ref{lst11}是代码\ref{lst10}编译后反汇编的结果。第9行调用new申请内存，第8行是压栈new函数的第一个参数。new函数只有一个参数，即申请内存的大小，而代码\ref{lst10}中类A只有一个string类型的成员变量，类的大小是4个字节，\textsl{movl   \$0x4,(\%esp)}即表示调用new时，传入的入参是4。第11―12行是将new的返回值\footnote{即调用对象构造函数时传入的this指针。}压栈后调用类A的构造函数。第21―22行同样是先压栈new的返回值，然后调用类A的析构函数。第23―24行，压栈new的返回值后调用delete函数销毁对象。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst10,caption=C++代码]{list/test.cpp}
\end{spacing}

\begin{spacing}{1.0}
\lstinputlisting[label=lst11,caption=汇编代码,language={[x86masm]Assembler}]{list/test.s}
\end{spacing}

搞清楚了new和delete的工作原理后，接着分析new{[]}和delete{[]}的原理。代码\ref{lst12}和代码\ref{lst13}分别是gcc中libstdc++实现的new{[]}和delete{[]}函数。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst12,caption=new{[]}函数]{list/new_opv.cpp}
\end{spacing}

\begin{spacing}{1.0}
  \lstinputlisting[label=lst13,caption=delete{[]}]{list/del_opv.cpp}
\end{spacing}
从实现来看，new[]、delete[]就是new、delete的简单封装，没有任何区别，但在功能上，两者有很大差异。几乎相同的代码却有着不同的功能，这个差异也是由编译器在编译阶段完成的。

将代码\ref{lst10}稍做修改，修改为调用new[]申请0x10个类A的对象，在函数退出前调用delete[]将这些对象销毁，修改后的代码如\ref{lst14}所示。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst14,caption=测试代码]{list/test1.cpp}
\end{spacing}

代码\ref{lst14}编译后反汇编的代码如下所示：
\begin{spacing}{1.0}
\lstinputlisting[label=lst15,caption=汇编代码,language={[x86masm]Assembler}]{list/test1.s}
\end{spacing}

代码\ref{lst15}的第10行调用new[]申请内存，第9行将new[]的参数压栈，{\color{red}但压栈的值是0x44，而不是0x40}。类A的大小是4字节，0x10个A的对象应该是0x40字节，但这两行指令的功能是申请0x44字节的内存，这就是new[]和new最本质的不同。多申请的4字节作用是什么，接着看后面的代码。

11―12行的功能是获取new[]的返回值，即本次申请内存的起始地址，然后将该地址的值赋为0x10，即在new[]返回地址的起始4个字节保存本次申请对象的个数。

13―23行的功能是从new[]返回的地址+4开始，调用0x10次类A的构造函数，每次调用构造函数传入的this指针是：new[]返回的地址 + 4 + 4n，其中n为从0开始循环0x10次的循环计数。

24―29行的作用是调用printf函数打印地址（new返回的地址 + 4，即代码\ref{lst14}中的pb指针）。

30―43行代码的作用是调用申请的0x10个对象的析构函数，注意析构函数的调用顺序正好和构造函数相反，构造函数的调用是从低地址对象一直到高地址对象，而析构是先析构高地址对象再析构低地址对象。

44―47行代码的作用是调用delete[]函数释放内存，注意调用delete[]函数时，传入的指针是new[]返回的地址，而不是代码\ref{lst14}中的pb指针指向的地址。

结合前面分析的malloc的内存布局，画出代码\ref{lst14}中申请0x10个类A对象的内存布局如图\ref{fig02}所示\footnote{图\ref{fig02}中所示的内存布局有一个前提假设是malloc分配的可使用内存正好等于上层应用申请的内存。}。
\input{figure/memory_lay_out}

综上所述，new[]的实现原理是：调用new申请比实际申请内存多4字节的内存，并在多出的4字节内存地址处保存动态申请的对象个数，最后再从new返回的地址加4开始，循环调用类的构造函数；delete[]则是new[]的逆向过程，先从new[]返回的地址读取要释放对象的个数，然后调用每个对象的析构函数，最后调用delete释放内存。

\section{内存泄露？}
搞清楚malloc/free、new/delete和new[]/delete[]的原理后，再回到问题的开始，代码\ref{lst1}和\ref{lst2}这种使用方式的问题在哪儿？

代码\ref{lst2}中，struct B的成员info定义为struct A的数组，但该数组没有指定长度。可能原作者将这个数组理解为一个变长数组，这样的话，使用代码
\begin{center}
pb = new char [sizeof(B) + nelems*sizeof(A)];
\end{center}
申请内存后，nelems*sizeof(A)变成了B的成员变量，即info数组中的元素，所以在使用
\begin{center}
delete [] pb;
\end{center}
释放内存时，这段内存也会一起释放。但实际上info在B中是一个0长数组，只是一个占位符，在B的内存模型中，info不占任何内存。0长数组的使用是C语言编码的一个技巧，最常用的场景就是TLV编码。TLV编码是为了在进程间传递消息，这就要求编码的结构其内存是连续的，如代码\ref{lst16}所示。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst16,caption=TLV]{list/tlv.c}
\end{spacing}

读者可以猜测一下代码\ref{lst16}的输出结果。只看这个样例代码，似乎正好说明了TLV中的value就是一个变长数组：第一个例子中，其长度是0x10，第二个例子中，其长度是10。除此之外，value的值同样可以使用数组下标的方式来获取。但这仅仅是因为申请tlv1和tlv2的内存是连续的，而并不是因为value是动态的，因为对于任何一个类型，编译器在编译时必须确定其大小，否则代码中使用到该类型的变量时，编译器将无法生成为其分配内存的代码。

前面说过value[0]或value[]其实是一个0长数组，只是一个占位符，在TLV结构中，其所占内存大小为0，所以struct TLV的sizeof结果是8。那这个占位符究竟有何作用？试想下，如果不定义这个占位符，进程间使用TLV结构通信，那接收端在解析TLV时，先解析到TLV的起始地址，然后从该地址加8开始取数据；但定义了这个占位符后，代码就可以这样写：
\begin{center}
strcpy(target, TLV->value, TLV->length);
\end{center}
即由编译器在生成代码时自动从TLV + 8开始拷贝length长度的内容，而不需要由程序员考虑实际的value到底是从哪个地址开始的。

了解了0长数组的功能后，那么代码\ref{lst1}中通过delete [] pb释放代码\ref{lst2}中通过new char [sizeof(B) + nelems*sizeof(A)];申请的内存肯定是有问题的，因为delete [] pb只会释放B对应的8字节内存，剩余的nelems*sizeof(A)字节的内存会泄露。实际情况是不是这样，继续分析。

按照前面分析的new []和delete []的原理，new char [sizeof(B) + nelems*sizeof(A)];会申请(sizeof(B) + nelems*sizeof(A) + 4)个字节的内存，然后在申请的内存的开始4字节保存本次申请的char对象的个数，即(sizeof(B) + nelems*sizeof(A))；而delete [] pb会从pb指向内存地址的前4个字节读取对象B的个数，然后再循环调用B的析构函数，最后通过delete (pb + 4)释放内存。按照这个分析，这段代码在运行时有很大概率会出现进程异常退出，因为通过new char [sizeof(B) + nelems*sizeof(A)];申请的内存的范围是0―(sizeof(B) + nelems*sizeof(A))\footnote{实际通过new申请的地址不会从0开始，这里只是为了说明问题简化描述。}，而通过delete [] pb释放内存前，调用B的构造函数访问的内存范围是0―(sizeof(B) + nelems*sizeof(A))*8\footnote{B的大小是8字节，从0开始遍历(sizeof(B) + nelems*sizeof(A))个B的对象，其操作的内存范围是0~(sizeof(B) + nelems*sizeof(A))*8。}，这会因为内存越界而导致进程异常退出。

综上所述，这段代码会导致进程退出，而不是内存泄露。但对这段代码对应的功能反复测试，结果一切正常，即不会内存泄露，也不会进程退出。为了搞清楚这段代码到底有没有问题，把代码\ref{lst1}和代码\ref{lst2}合并成一份代码\ref{lst17}。代码\ref{lst17}编译反汇编后的结果如代码\ref{lst18}所示。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst17,caption=测试代码]{list/test2.cpp}
\end{spacing}
\begin{spacing}{1.0}
\lstinputlisting[label=lst18,caption=汇编代码,language={[x86masm]Assembler}]{list/test2.s}
\end{spacing}

代码\ref{lst18}的第9行调用new []申请内存，第8行将\%eax寄存器中的值压栈作为new []的入参，即本次申请内存的大小；而\%eax寄存器中的值是0x8 + 0x660，即本次申请内存的实际大小，并没有像之前分析的new []操作会多申请4个字节的内存保存本次申请对象的个数。

第14行调用printf打印指针pa；15行判断pb指针是否为空，如果不为空则执行17行，而17―18行的作用是将pb指针压栈，作为19行调用delete []的入参，最终由19行的delete []将内存释放。

这样分析后发现，整个内存申请和释放过程中，没有任何对象的构造和析构函数被调用。再结合最前面的分析，new []和delete []其实就是new和delete的简单封装，而new和delete最终是通过malloc和free申请和释放内存的，按照这个顺序一步一步往下推导，最终可以得出这样的结论：代码\ref{lst17}中main函数的功能和代码\ref{lst19}中main函数的功能完全等价。
\begin{spacing}{1.0}
  \lstinputlisting[label=lst19,caption=测试代码]{list/test3.cpp}
\end{spacing}

对代码\ref{lst19}中内存的申请和释放，相信不会有任何人会怀疑其有内存泄露或会由于内存越界导致进程退出。这就是代码\ref{lst1}和代码\ref{lst2}在数据类型不配套的情况下使用new []和delete []即不会内存泄露也不会引起进程重启的真正原因，因为在该场景下，new [] 和 delete []最终会“退化”成了malloc和free。

问题搞清楚了，结论是该场景下这样使用没问题，前提条件是new的数据类型无构造函数、delete的的数据类型无析构函数。也许有人会问，char类型没有构造和析构函数很好理解，为什么struct B也即没有构造也没有析构函数？在不显式定义类的构造和析构的场景下，编译器难道不会为该类自动生成这两个函数？答案是确实不会，为什么不会，感兴趣的同学可以参考下C++大师Stanley B. Lippman的《深度探索C++对象模型》这本书，在书里作者详细描述了构造、析构以及拷贝构造这些函数哪些场景下编译器会自动生成，哪些场景下不会。

最后，给代码\ref{lst17}中的B显示定义一个空的析构函数B() {return;}，编译并运行该程序，结果如下：
\begin{spacing}{1.0}
  \lstinputlisting[language=sh,label=lst20,caption=core dumped]{list/test.sh}
\end{spacing}
\noindent{进程会core dumped，感兴趣的同学可以思考下，这个core dumped是因为引用了图\ref{fig02}中的哪个地址导致的。}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%% 正文部分结束%%%%%%%%%%%%%%%%%%%%%%

